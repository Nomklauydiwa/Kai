import * as THREE from "https://esm.sh/three";

/* ---------------- Constants ---------------- */
const minTileIndex = -8;
const maxTileIndex = 8;
const tilesPerRow = maxTileIndex - minTileIndex + 1;
const tileSize = 42;
const maxScore = 100;

/* ---------------- Scene ---------------- */
const scene = new THREE.Scene();
const clock = new THREE.Clock();

/* ---------------- Camera ---------------- */
function Camera() {
  const size = 300;
  const viewRatio = window.innerWidth / window.innerHeight;
  const width = viewRatio < 1 ? size : size * viewRatio;
  const height = viewRatio < 1 ? size / viewRatio : size;
  const camera = new THREE.OrthographicCamera(width/-2,width/2,height/2,height/-2,100,900);
  camera.up.set(0,0,1);
  camera.position.set(300,-300,300);
  camera.lookAt(0,0,0);
  return camera;
}
const camera = Camera();

/* ---------------- Renderer ---------------- */
function Renderer() {
  const canvas = document.querySelector("canvas.game");
  const renderer = new THREE.WebGLRenderer({ canvas, alpha:true, antialias:true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  return renderer;
}
const renderer = Renderer();

/* ---------------- Player ---------------- */
const player = new THREE.Group();
const playerBody = new THREE.Mesh(
  new THREE.BoxGeometry(15,15,20),
  new THREE.MeshLambertMaterial({ color:"white", flatShading:true })
);
playerBody.position.z = 10;
player.add(playerBody);
scene.add(player);

/* ---------------- Map ---------------- */
const map = new THREE.Group();
scene.add(map);

let metadata = [];
let position = { currentRow:0, currentTile:0 };
let movesQueue = [];

/* ---------------- Controls ---------------- */
document.getElementById("forward").addEventListener("click",()=>queueMove("forward"));
document.getElementById("backward").addEventListener("click",()=>queueMove("backward"));
document.getElementById("left").addEventListener("click",()=>queueMove("left"));
document.getElementById("right").addEventListener("click",()=>queueMove("right"));
window.addEventListener("keydown",(event)=>{
  if(event.key==="ArrowUp"){ event.preventDefault(); queueMove("forward"); }
  else if(event.key==="ArrowDown"){ event.preventDefault(); queueMove("backward"); }
  else if(event.key==="ArrowLeft"){ event.preventDefault(); queueMove("left"); }
  else if(event.key==="ArrowRight"){ event.preventDefault(); queueMove("right"); }
});

/* ---------------- UI ---------------- */
const scoreDOM = document.getElementById("score");
const resultDOM = document.getElementById("result-container");
const finalScoreDOM = document.getElementById("final-score");
const resultTitle = document.getElementById("result-title");
document.getElementById("retry").addEventListener("click",initializeGame);

/* ---------------- Game Functions ---------------- */
function queueMove(direction){
  if(!endsUpInValidPosition({rowIndex:position.currentRow,tileIndex:position.currentTile},[...movesQueue,direction])) return;
  movesQueue.push(direction);
}
function stepCompleted(){
  const direction = movesQueue.shift();
  if(direction==="forward") position.currentRow++;
  if(direction==="backward") position.currentRow--;
  if(direction==="left") position.currentTile--;
  if(direction==="right") position.currentTile++;
  if(position.currentRow>metadata.length-10) addRows();
  scoreDOM.innerText = position.currentRow;
  if(position.currentRow>=maxScore){
    resultTitle.innerText = "You Win!";
    resultDOM.style.visibility="visible";
    finalScoreDOM.innerText = position.currentRow;
  }
}
function endsUpInValidPosition(currentPosition,moves){
  const finalPos = moves.reduce((pos,d)=>{
    if(d==="forward") return {...pos,rowIndex:pos.rowIndex+1};
    if(d==="backward") return {...pos,rowIndex:pos.rowIndex-1};
    if(d==="left") return {...pos,tileIndex:pos.tileIndex-1};
    if(d==="right") return {...pos,tileIndex:pos.tileIndex+1};
    return pos;
  },currentPosition);
  if(finalPos.rowIndex===-1 || finalPos.tileIndex<minTileIndex || finalPos.tileIndex>maxTileIndex) return false;
  return true;
}

/* ---------------- Map & Rows ---------------- */
function addRows(){
  const newRows = Array.from({length:20},()=>({type:"empty"}));
  metadata.push(...newRows);
}
function initializeMap(){ metadata=[]; map.clear(); addRows(); }

/* ---------------- Animate ---------------- */
function animatePlayer(){
  if(!movesQueue.length) return;
  const direction = movesQueue[0];
  const startX = position.currentTile*tileSize;
  const startY = position.currentRow*tileSize;
  let endX=startX,endY=startY;
  if(direction==="left") endX-=tileSize;
  if(direction==="right") endX+=tileSize;
  if(direction==="forward") endY+=tileSize;
  if(direction==="backward") endY-=tileSize;
  const progress = Math.min(1, clock.getElapsedTime()/0.2);
  player.position.x = THREE.MathUtils.lerp(startX,endX,progress);
  player.position.y = THREE.MathUtils.lerp(startY,endY,progress);
  player.children[0].position.z = Math.sin(progress*Math.PI)*8;
  if(progress>=1){ stepCompleted(); clock.start(); movesQueue.shift(); }
}
function animate(){
  animatePlayer();
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}

/* ---------------- Initialize Game ---------------- */
function initializeGame(){
  position={currentRow:0,currentTile:0};
  movesQueue=[];
  initializeMap();
  scoreDOM.innerText="0";
  resultDOM.style.visibility="hidden";
  clock.start();
}
initializeGame();
animate();