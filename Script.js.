import * as THREE from "https://esm.sh/three";

/* -------- Constants -------- */
const minTileIndex = -8;
const maxTileIndex = 8;
const tileSize = 42;
const totalSteps = 100; // เส้นชัย
let gameOver = false;
let score = 0;

/* -------- Scene & Camera -------- */
const scene = new THREE.Scene();

const camera = new THREE.OrthographicCamera(
  window.innerWidth / -2,
  window.innerWidth / 2,
  window.innerHeight / 2,
  window.innerHeight / -2,
  100,
  900
);
camera.up.set(0, 0, 1);
camera.position.set(300, -300, 300);
camera.lookAt(0, 0, 0);

/* -------- Renderer -------- */
const renderer = new THREE.WebGLRenderer({
  alpha: true,
  antialias: true,
  canvas: document.querySelector("canvas.game"),
});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;

/* -------- Lights -------- */
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(-100, -100, 200);
scene.add(dirLight);

/* -------- UI Elements -------- */
const scoreDOM = document.getElementById("score");
const resultDOM = document.getElementById("result-container");
const finalScoreDOM = document.getElementById("final-score");
const resultTitleDOM = document.getElementById("result-title");

/* -------- Player -------- */
const player = new THREE.Group();
scene.add(player);
const position = { currentRow: 0, currentTile: 0 };
const movesQueue = [];

/* -------- Map & Metadata -------- */
const metadata = [];
const map = new THREE.Group();
scene.add(map);
const items = []; // เก็บไอเทม

/* -------- Utility Functions -------- */
function randomElement(array) {
  return array[Math.floor(Math.random() * array.length)];
}

/* -------- Player Model -------- */
function createPlayer() {
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(15, 15, 20),
    new THREE.MeshLambertMaterial({ color: "white" })
  );
  body.position.z = 10;
  player.add(body);

  const cap = new THREE.Mesh(
    new THREE.BoxGeometry(2, 4, 2),
    new THREE.MeshLambertMaterial({ color: 0xf0619a })
  );
  cap.position.z = 21;
  player.add(cap);
}

/* -------- Vehicle Models -------- */
function Car(initialTileIndex, direction, color) {
  const car = new THREE.Group();
  car.position.x = initialTileIndex * tileSize;
  if (!direction) car.rotation.z = Math.PI;
  const main = new THREE.Mesh(
    new THREE.BoxGeometry(60, 30, 15),
    new THREE.MeshLambertMaterial({ color })
  );
  main.position.z = 12;
  car.add(main);
  return car;
}

function Truck(initialTileIndex, direction, color) {
  const truck = new THREE.Group();
  truck.position.x = initialTileIndex * tileSize;
  if (!direction) truck.rotation.z = Math.PI;
  const main = new THREE.Mesh(
    new THREE.BoxGeometry(70, 35, 35),
    new THREE.MeshLambertMaterial({ color })
  );
  main.position.z = 20;
  truck.add(main);
  return truck;
}

function Grass(rowIndex) {
  const grass = new THREE.Group();
  grass.position.y = rowIndex * tileSize;
  const plane = new THREE.Mesh(
    new THREE.BoxGeometry(tileSize * 8, tileSize, 3),
    new THREE.MeshLambertMaterial({ color: 0x7bbf48 })
  );
  grass.add(plane);
  return grass;
}

function Road(rowIndex) {
  const road = new THREE.Group();
  road.position.y = rowIndex * tileSize;
  const plane = new THREE.Mesh(
    new THREE.BoxGeometry(tileSize * 8, tileSize, 3),
    new THREE.MeshLambertMaterial({ color: 0x333 })
  );
  road.add(plane);
  return road;
}

/* -------- Items -------- */
function Item(tileIndex, rowIndex) {
  const item = new THREE.Mesh(
    new THREE.SphereGeometry(5, 16, 16),
    new THREE.MeshLambertMaterial({ color: 0xffea00 })
  );
  item.position.x = tileIndex * tileSize;
  item.position.y = rowIndex * tileSize;
  item.position.z = 10;
  scene.add(item);
  return item;
}

/* -------- Generate Rows -------- */
function generateRow(rowIndex) {
  const type = randomElement(["car", "truck", "forest", "item"]);
  if (type === "car") return { type, direction: randomElement([true, false]), vehicles: [{ initialTileIndex: randomElement([-5, 0, 5]), color: 0xa52523 }] };
  if (type === "truck") return { type, direction: randomElement([true, false]), vehicles: [{ initialTileIndex: randomElement([-4, 1, 4]), color: 0x78b14b }] };
  if (type === "item") return { type: "item", tileIndex: randomElement([-7, -4, 0, 4, 7]) };
  return { type: "forest" };
}

function addRows(amount = 1) {
  for (let i = 0; i < amount; i++) {
    const rowIndex = metadata.length;
    const rowData = generateRow(rowIndex);
    metadata.push(rowData);

    if (rowData.type === "forest") map.add(Grass(rowIndex));
    else if (rowData.type === "car") {
      const road = Road(rowIndex);
      rowData.vehicles.forEach(v => road.add(Car(v.initialTileIndex, rowData.direction, v.color)));
      map.add(road);
    } else if (rowData.type === "truck") {
      const road = Road(rowIndex);
      rowData.vehicles.forEach(v => road.add(Truck(v.initialTileIndex, rowData.direction, v.color)));
      map.add(road);
    } else if (rowData.type === "item") {
      items.push(Item(rowData.tileIndex, rowIndex));
      map.add(Grass(rowIndex));
    }
  }
}

/* -------- Input -------- */
document.getElementById("forward")?.addEventListener("click", () => movesQueue.push("forward"));
document.getElementById("backward")?.addEventListener("click", () => movesQueue.push("backward"));
document.getElementById("left")?.addEventListener("click", () => movesQueue.push("left"));
document.getElementById("right")?.addEventListener("click", () => movesQueue.push("right"));
window.addEventListener("keydown", (event) => {
  if (event.key === "ArrowUp") movesQueue.push("forward");
  if (event.key === "ArrowDown") movesQueue.push("backward");
  if (event.key === "ArrowLeft") movesQueue.push("left");
  if (event.key === "ArrowRight") movesQueue.push("right");
});

/* -------- Game Logic -------- */
function movePlayer() {
  if (!movesQueue.length || gameOver) return;
  const move = movesQueue.shift();
  if (move === "forward") position.currentRow++;
  if (move === "backward") position.currentRow--;
  if (move === "left") position.currentTile--;
  if (move === "right") position.currentTile++;
  score = position.currentRow;
  scoreDOM.innerText = score;
}

function hitTest() {
  const row = metadata[position.currentRow];
  if (!row) return;

  if (row.type === "car" || row.type === "truck") {
    gameOver = true;
    resultDOM.style.visibility = "visible";
    finalScoreDOM.innerText = score;
    resultTitleDOM.innerText = "Game Over";
  }

  if (row.type === "item") {
    const index = items.findIndex(it => it.position.y / tileSize === position.currentRow && it.position.x / tileSize === position.currentTile);
    if (index !== -1) {
      score += 5; // เก็บไอเทมได้ +5
      scoreDOM.innerText = score;
      scene.remove(items[index]);
      items.splice(index, 1);
    }
  }
}

function checkFinishLine() {
  if (position.currentRow >= totalSteps) {
    gameOver = true;
    resultDOM.style.visibility = "visible";
    finalScoreDOM.innerText = totalSteps;
    resultTitleDOM.innerText = "You Win!";
  }
}

/* -------- Animate -------- */
function animate() {
  movePlayer();
  hitTest();
  checkFinishLine();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

/* -------- Retry -------- */
document.querySelector("#retry")?.addEventListener("click", () => {
  gameOver = false;
  position.currentRow = 0;
  position.currentTile = 0;
  movesQueue.length = 0;
  metadata.length = 0;
  items.length = 0;
  map.remove(...map.children);
  addRows(20);
  scoreDOM.innerText = "0";
  resultDOM.style.visibility = "hidden";
});

/* -------- Start Game -------- */
createPlayer();
addRows(20);
animate();